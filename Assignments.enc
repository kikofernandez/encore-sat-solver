module Assignments

import Vector
import Clause
import Array

local class Variable
-- public attributes
  var value : int
  var dL : int
  var setByBranching : bool
  var guessedValue : int
  var visited : bool

  def init() : unit
    this.value = -1
    this.dL = -1
    this.setByBranching = false
    this.guessedValue = -1
    this.visited = false
  end

  def toString() : unit
    println("Value: {}, dL: {}, setByBranching: {}, guessedValue: {}, visited: {}", this.value, this.dL, this.setByBranching, this.guessedValue, this.visited)
  end
end

local class Assignments
-- public attributes
  var nSetVars : int
-- private attributes
  var variables : Array[Variable]

  def init(n : int, varsToAssign : RArray[int]) : unit
    this.variables = new Array[Variable](n)
    repeat i <- n do
      this.variables.set(i, new Variable())
    end
    this.nSetVars = 0
    for i <- [0 .. varsToAssign.size() - 1] do
      this.guessVariable(varsToAssign.at(i), 1, -1, false)
    end
  end

-- public methods
  def assignVariable(index :  int, value : int, dL : int, setByBranching : bool) : unit
    var vara = this.variables.at(index)
    if (vara.value == -1) then
      vara.value = value
      vara.dL = dL
      vara.setByBranching = setByBranching
    else
      print("Assign variable error, index {} already has a value.\n", index)
      vara.toString()
      exit(0)
    end
    this.nSetVars = this.nSetVars + 1
  end

  -- TODO: copy not using intermediate vector
  def getVariables() : RArray[Variable]
    val size = this.variables.size()
    var newVars = new Array[Variable](size/2)
    repeat i <- size do
      if (i%2 == 0) then
        newVars.set(i, this.variables.at(i))
      end
    end
    consume newVars
  end

  def resetVar(index : int) : unit
    val index1 = index*2
    val index2 = index1+1
    var var1 = this.variables.at(index1)
    var var2 = this.variables.at(index2)
    if (var1.value != -1) then
      this.nSetVars = this.nSetVars - 1
    end
    if (var2.value != -1) then
      this.nSetVars = this.nSetVars - 1
    end
    var1.value = -1
    var2.value = -1
    var1.dL = -1
    var2.dL = -1
    var1.setByBranching = false
    var2.setByBranching = false
    var1.guessedValue = -1
    var2.guessedValue = -1
  end

  def assignCounterpart(index : int) : unit
    var index2 = index
    if (index%2 == 0) then
      index2 = index2+1
    else
      index2 = index2-1
    end
    var var1 = this.variables.at(index)
    var var2 = this.variables.at(index2)
    if (var2.value == -1) then
      var2.value = var1.value
      var2.dL = var1.dL
      var2.setByBranching = var1.setByBranching
    else
      println("Assign counterpart error, variable index {} already has a value.", index2)
      var2.toString()
      exit(0)
    end
    this.nSetVars = this.nSetVars + 1
  end

  def guessVariable(index :  int, value : int, dL : int, setByBranching : bool) : unit
    -- TODO: precondition: |this.variables| >= (index*2)+1
    val index1 = index*2
    val index2 = index1+1
    val var1 = this.variables.at(index1)
    val var2 = this.variables.at(index2)
    if ((var1.value == -1) && (var2.value == -1)) then
      var1.value = value
      var2.value = value
      var1.dL = dL
      var2.dL = dL
      var1.setByBranching = true
      var2.setByBranching = true
    else
      println("Guess variable error, variable index {} already has a value.", index2)
      var1.toString()
      var2.toString()
      exit(0)
    end
    this.nSetVars = this.nSetVars + 2
  end

  def getUnassignedIndexes() : [int]
    val size = this.variables.size()
    val indexes = new Vector[int](size)
    repeat i <- size do
      val vara = this.variables.at(i)
      if (vara.value == -1) then
        indexes.push(i)
      end
    end
    indexes.toArray()
  end

  -- TODO: convert to straight array copy
  def toArray() : [int]
    val size = this.variables.size()
    val variables = new Vector[int](size)
    repeat i <- size do
      val vara = this.variables.at(i)
      variables.push(vara.value)
    end
    variables.toArray()
  end

{- TODO: remove if possible
  def toString() : unit
    print("Assignments: ")
    val variables = this.getVariables()
    repeat i <- |variables| do
      var vara = variables(i)
      if (vara.value == 0) then
        print("{}","-")
      else if (vara.value == -1) then
        print("{}","UNSAT")
      end
      print("x{} ",i+1)
      if (((i+1)*2)%5 == 0) then
        println("")
      end
    end
    println("")
  end
-}

  def final() : FinalAssignment
    new FinalAssignment(consume this.variables)
  end

  def convertClauseToConflictClause(clause : Clause) : Clause
    var conflictLiterals = new Vector[int](1)
    repeat j <- |clause.literals| do
      var unique = true
      var loop = true
      var k = 0
      var literal = clause.literals(j)
      var vara = this.variables.at(literal)
      if (vara.value == 0) then
        if (literal%2 == 1) then
          literal = literal-1
        end
      else
        if (literal%2 == 0) then
          literal = literal+1
        end
      end
      conflictLiterals.push(literal)
    end
    new Clause(conflictLiterals.toArray())
  end
end

read class FinalAssignment
  val assignment : RArray[int]

  def init(var vars : Array[Variable]) : unit
    val size = vars.size()
    var assignment = new Array[int](size)
    repeat i <- size do
      assignment.set(i, vars.at(i).value)
    end
    this.assignment = consume assignment
  end

  def toString() : unit
    print("Assignments: ")
    repeat i <- this.assignment.size() do
      if (this.assignment.at(i) == 0) then
        print("{}","-")
      else if (this.assignment.at(i) == -1) then
        print("{}","UNSAT")
      end
      print("x{} ",i+1)
      if (((i+1)*2)%5 == 0) then
        println("")
      end
    end
    println("")
  end
end
