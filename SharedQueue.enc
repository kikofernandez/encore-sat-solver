module SharedQueue

import Clause
import Array

--
-- Design idea:
--
-- Shared queue is a way of encoding the Circuit Breaker pattern and free
-- the pollers from calling and blocking on active objects. Internally, there
-- is an active object to whom the queue sends messages when the active object
-- can keep up the work. Otherwise, trying to pull from the queue may return
-- Nothing and the poller needs to handle that case.
--
-- This pattern is useful in situations where there is a poller object that
-- would like to get information from the queue and, if the queue does not
-- contain information, the poller can continue performing some other work.
--

-- TODO: NOT FINISHED
active class ActiveQueue[read t]
  def push(item : t): unit
    ()
  end

  def pop(): Maybe[t]
    Nothing
  end
end

-- TODO: NOT FINISHED
-- Create a non-blocking queue that controls that, after X number of errors,
-- it moves to a half-open state returning Nothing sometimes and a value some other
-- times.
read class SharedQueue[read t]
  val aQueue : ActiveQueue[t]
  val buffer : RArray[t]
  val indexBuffer : int

  -- state:
  -- 0 -> closed circuit, works as normall
  -- 1 -> half-open, some requests may go through
  -- 2 -> open, the queue is non-responsive, return Nothing
  -- var state : int

  def init(bufferSize : int): unit
    this.aQueue = new ActiveQueue[t]()
    this.buffer = new Array[t](bufferSize)
  end

  def push(item: t): unit
    EMBED (int)
      #{this.indexBuffer} = __atomic_add_fetch(&#{this.indexBuffer}, 1, __ATOMIC_SEQ_CST);
    END
    this.aQueue!push(item)
  end

  def pop(): Maybe[t]
    if this.indexBuffer == 0 then
      Nothing
    else
      val oldIndex = EMBED (int) __atomic_fetch_sub(&#{this.indexBuffer}, 1, __ATOMIC_SEQ_CST); END
      Just(this.buffer.at(oldIndex))
    end
  end
end

read class Solution
  -- private attribute
  val solved : bool = false

  def getIsSolved(): bool
    EMBED (bool)
      __atomic_load_n(&#{this.solved}, __ATOMIC_ACQUIRE);
    END
  end

  def setSolved(): bool
    EMBED (bool)
      int64_t expected = 0;
      __atomic_compare_exchange_n(&#{this.solved}, &expected, true, true, __ATOMIC_RELEASE, __ATOMIC_RELEASE);
    END
  end
end
