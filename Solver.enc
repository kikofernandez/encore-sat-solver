module Solver

import VVector
import Clause
import Main
import Heuristic
import CDCL
import Assignments
import Util
import Array
import Util

active class Solver
  val n_vars : int
  -- cdcl: each CDCL shares clauses and heuristics.
  val cdcl : CDCL
  val master : Main  -- actor
  val solverId : int
  val iterations : int -- How long to spin before calling itself with a message
  val ccLength : int
  val restartCounterMax : int
  val ccNum : int -- How many conflict clauses to send
  val ccM : int

  var ccSent : int = 0
  var ccCounter : int = -1
  var restartCounter : int = 0

  -- TODO: varsToAssign is a read-only array
  def init(clauses : RVector[Clause], n_vars : int, varsToAssign : RArray[int],
           var heuristic : Heuristic, master : Main, solverId : int,
           ccLength : int, iterations : int, ccNumber : int, ccM : int,
           restart : int) : unit
    this.n_vars = n_vars
    this.master = master
    this.cdcl = new CDCL(clauses, this.n_vars, varsToAssign, consume heuristic, solverId)
    this.solverId = solverId
    this.ccLength = ccLength
    this.iterations = iterations
    this.ccNum = ccNumber
    this.ccM = ccM
    this.restartCounterMax = restart
  end

  def start() : unit
    val solveable = true
    val done = false
    WAMP("Started Solver.")
    this.loop(solveable, done)
  end

  -- TODO: some work to elimate the gets
  def finishLoop(solveable : bool) : unit
    this.master!isSolvedProtocolFinish(this, solveable)
  end

  def finishLoop2(isSolved: bool, solveable: bool): unit
    if not isSolved then
      if solveable then
        this.master!setSolved()
        println("Satisfiable!")
        this.cdcl!checkCorrectness3(this, solveable)
      else
        println("Problem found unsatisfiable by solver {}", this.solverId)
      end
    end
  end

  def finishLoop3(correct: bool, solveable: bool): unit
    if correct && solveable then
      println("Solution is correct, and was found by solver number {}:", this.solverId)
      -- TODO: make this one call!
      this.cdcl!variableAndValueSelectionString(this)
    else
      println("Solution is incorrect.")
      this.finishLoop4()
    end
  end

  def finishLoop4(): unit
    this.cdcl!getAll()
  end

  def solveProtocol2(solved: bool, solveable: bool, done: bool): unit
    WAMP("solveProtocol2")
    if (solveable && not done && not solved) then
      this.cdcl!solveProtocol3(this)
    else
      WAMP("finishloop")
      this.finishLoop(solveable)
    end
  end

  def solveProtocol4(res: (bool, bool, bool)): unit
    WAMP("solveProtocol4")
    val solveable = res.0 -- solvable
    val done = res.1 -- done
    if res.2 then -- conflict
      if this.ccNum == -1 || this.ccSent < this.ccNum then
        this.cdcl!getLatestConflictClauseProtocol5(this, solveable, done)
        return ()
      else
        return this.restart(solveable, done) -- restart always together with return
      end
    end
    return this.loop(solveable, done)
  end

  def solveProtocol6(conflictClause: Clause, solveable : bool, done : bool): unit
    WAMP("solveProtocol6")
    if this.ccLength == -1 || conflictClause.size() <= this.ccLength then
      this.ccCounter += 1
      if this.ccCounter % this.ccM == 0 then
        this.master ! addConflictClause(conflictClause, this.solverId)
        this.ccSent += 1
      end
    end
    this.restart(solveable, done)
  end

  def restart(solveable: bool, done: bool): unit
    this.restartCounter += 1
    if this.restartCounter == this.restartCounterMax then
      this.restartCounter = 0
      this.cdcl!restart()
    end
    this.loop(solveable, done)
  end

  -- TODO: much work to eliminate the gets
  def loop(solveable : bool, done : bool) : unit
    WAMP("Starting Loop.")
    WAMP("Iterating")
    this.master!isSolvedProtocol1(this, solveable, done)
  end

  def addConflictClause(conflictClause : Clause) : unit
    this.cdcl!addConflictClause(conflictClause)
  end
end
