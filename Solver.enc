module Solver

import VVector
import Clause
import Main
import Heuristic
import CDCL
import Assignments
import Util
import Array

active class Solver
  val n_vars : int
  -- cdcl: each CDCL shares clauses and heuristics.
  val cdcl : CDCL
  val master : Main  -- actor
  val solverId : int
  val iterations : int -- How long to spin before calling itself with a message
  val ccLength : int
  val restartCounterMax : int
  val ccNum : int -- How many conflict clauses to send
  val ccM : int

  var ccSent : int = 0
  var ccCounter : int = -1
  var restartCounter : int = 0

  -- TODO: varsToAssign is a read-only array
  def init(clauses : RVector[Clause], n_vars : int, varsToAssign : RArray[int],
           var heuristic : Heuristic, master : Main, solverId : int,
           ccLength : int, iterations : int, ccNumber : int, ccM : int,
           restart : int) : unit
    this.n_vars = n_vars
    this.master = master
    this.cdcl = new CDCL(clauses, this.n_vars, varsToAssign, consume heuristic, solverId)
    this.solverId = solverId
    this.ccLength = ccLength
    this.iterations = iterations
    this.ccNum = ccNumber
    this.ccM = ccM
    this.restartCounterMax = restart
  end

  def start() : Maybe[(int, int, FinalAssignment)]
    var solveable = Nothing : Maybe[bool]
    WAMP("Started Solver.")
    -- FIXME
    var solved = this.loop(solveable)
    solveable = solved.0
    var result = solved.1
    while isNothing(result) && isNothing(solveable) do
      solved = this.loop(solveable)
      solveable = solved.0
      result = solved.1
      -- print("{}.{}-", solveable, result)
    end
    return result
    -- this.loop(solveable)
    -- return Nothing
  where
    fun isNothing[t](solved : Maybe[t]): bool
      match solved with
        case Nothing => true
        case otherwise => false
      end
    end
  end

  -- TODO: some work to elimate the gets
  def private finishLoop(solveable : Maybe[bool]) : Maybe[(int, int, FinalAssignment)]
    if not get(this.master!getIsSolved()) then
      val s = match solveable with
                case Nothing      => abort("Error on finishLoop")
                case Just(true)   => true
                case Just(false)  => false
              end
      if s then
        this.master!setSolved() -- critical region
        println("Satisfiable!")
        val correct = get(this.cdcl!checkCorrectness())
        if correct && s then
          println("Solution is correct, and was found by solver number {}:", this.solverId)
	  -- TODO: make this one call!
          get(this.cdcl!variableAndValueSelectionPrintout())
        else
          println("Solution is incorrect.")
        end

	-- TODO: make these one call (probably just return all results
	-- from CDCL in one object)
        val conflicts = get(this.cdcl!getAllConflicts())
        val assignments = get(this.cdcl!getAssignments())
        assignments.toString()
        println("Number of own conflicts: {}, number of received conflicts {}", conflicts.0, conflicts.1)
        println("")
        return Just((conflicts.0, conflicts.1, assignments))
      else
        println("Problem found unsatisfiable by solver {}", this.solverId)
        return Nothing
      end
    end
    return Nothing
  end

  -- TODO: much work to eliminate the gets
  def loop(var solveable : Maybe[bool]) : (Maybe[bool], Maybe[(int, int, FinalAssignment)])
    WAMP("Starting Loop.")
    var i = 0
    while (i < this.iterations) do
      WAMP("Iterating")
      -- TODO: bad design. blocking in a while loop...
      var solved = get(this.master!getIsSolved())
      if isUnknown(solveable) && not solved then
        val res = get(this.cdcl!solve())
        solveable = orMaybe(res.0, solved)
        if res.1 then -- conflict
          if this.ccNum == -1 || this.ccSent < this.ccNum then
            val conflictClause = get(this.cdcl!getLatestConflictClause())
            if this.ccLength == -1 || conflictClause.size() <= this.ccLength then
              this.ccCounter += 1
              if this.ccCounter % this.ccM == 0 then
                this.master ! addConflictClause(conflictClause, this.solverId)
                this.ccSent += 1
              end
            end
          end

          -- Considers restarting the process. this is done to start all over
          -- from 0 but keeping the accumulated knowledge from the learnt clauses.
          this.restartCounter += 1
          if this.shouldRestart() then
            this.applyRestart()
          end
        end
        if not isUnknown(solveable) then
          return (solveable, this.finishLoop(solveable))
        end
      else
        return (solveable, this.finishLoop(solveable))
      end
      i += 1
    end
    -- FIXME
    -- WAMP("Out bottom of iteration")
    -- val solver = this
    -- solver ! loop(solveable) -- send message to self to allow gc,
    --                                -- and addConflictClause to run
    this.suspend()
    return (orMaybe(solveable, get(this.master!getIsSolved())), Nothing)
  where
    fun orMaybe(solveable: Maybe[bool], stop : bool) : Maybe[bool]
      if stop then
        -- println("orStop: True")
        return Just(true)
      else
        match solveable with
          case Just(x) => do
                            -- println("orStop: {}", x || stop)
                            return Just(x || stop)
                          end
          case Nothing => do
                            -- println("orStop: Nothing")
                            return Nothing
                          end
        end
      end
    end

    fun isUnknown(solveable: Maybe[bool]): bool
      match solveable with
        case Nothing   => true
        case otherwise => false
      end
    end
  end

  def private shouldRestart(): bool
    this.restartCounter == this.restartCounterMax
  end

  def private applyRestart(): unit
    this.restartCounter = 0
    this.cdcl!restart()
  end

  def addConflictClause(conflictClause : Clause) : unit
    this.cdcl!addConflictClause(conflictClause)
  end
end
