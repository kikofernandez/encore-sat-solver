module Solver

import VVector
import Clause
import Main
import Heuristic
import CDCL
import Assignments
import Util
import Array
import Solution
import Observable

active class Proxy
  val solver: Solver

  def init(clauses : RVector[Clause], n_vars : int, varsToAssign : RArray[int],
           var heuristic : Heuristic, solverId : int,
           ccLength : int, iterations : int, ccNumber : int, ccM : int,
           restart : int, val foundSolution: Solution, val observable : active IObservable[Clause]) : unit
    this.solver = new Solver(clauses, n_vars, varsToAssign, consume heuristic, solverId, ccLength,
                             iterations, ccNumber, ccM, restart, foundSolution, observable)
    observable ! addObserver((solverId, this.solver))
  end

  def start(): Maybe[(int, int, FinalAssignment)]
    var solveable = Nothing : Maybe[bool]
    while true do
      val solution = get(this.solver!start(solveable))
      match solution.0 with
        case Nothing =>
          do
            -- we don't know if satisfiable in this solver and no other solver has yet found a solution
            Nothing : Maybe[(int, int, FinalAssignment)]
          end
        end
        case Just(true) =>
          do
            -- there is a solution. Check whether we found the solution or
            -- if someone else found the solution
            match solution.1 with
              -- case Nothing => someone else found the solution
              case Nothing => return Nothing
              -- case result => this solver found the solution
              case result =>  return result
            end
          end
        end
        -- problem is unsatisfiable. finish.
        case Just(false) => Nothing
      end
    end
    return Nothing
  end

end

active class Solver : IObserver[Clause](addConflictClause(), cdcl)
  val n_vars : int
  -- cdcl: each CDCL shares clauses and heuristics.
  val cdcl : CDCL
  val solverId : int
  val iterations : int -- How long to spin before calling itself with a message
  val ccLength : int
  val restartCounterMax : int
  val ccNum : int -- How many conflict clauses to send
  val ccM : int
  val foundSolution : Solution
  val observable : active IObservable[Clause]

  var ccSent : int = 0
  var ccCounter : int = -1
  var restartCounter : int = 0

  -- TODO: varsToAssign is a read-only array
  def init(clauses : RVector[Clause], n_vars : int, varsToAssign : RArray[int],
           var heuristic : Heuristic, solverId : int,
           ccLength : int, iterations : int, ccNumber : int, ccM : int,
           restart : int, val foundSolution: Solution, val observable : active IObservable[Clause]) : unit
    this.n_vars = n_vars
    this.cdcl = new CDCL(clauses, this.n_vars, varsToAssign, consume heuristic, solverId)
    this.solverId = solverId
    this.ccLength = ccLength
    this.iterations = iterations
    this.ccNum = ccNumber
    this.ccM = ccM
    this.restartCounterMax = restart
    this.foundSolution = foundSolution
    this.observable = observable
  end

  --
  -- writeSolution
  --
  -- method call when the solver has found a solution.
  -- possible outcomes: the solver is the first one to find a solution and returns
  -- that solution to the caller. the solver found a solution but is not the first
  -- one to find the problem satisfiable, returns Nothing.
  --
  -- Result:
  --
  -- case (Just(true), solution): problem is satisfiable and provide solution
  -- case (Just(true), Nothing): problem is satisfiable but this solver was not
  --                             the first one to find a solution.
  -- case (Just(false), Nothing): problem is not satisfiable
  -- case (Nothing, solution): error
  def private writeSolution(solveable : Maybe[bool]) : (Maybe[bool], Maybe[(int, int, FinalAssignment)])
    val hasSolution = match solveable with
                        case Nothing      => abort("Error on writeSolution")
                        case Just(true)   => true
                        case Just(false)  => false
                      end

    -- has solution and can atomically set it to true, then I am the solver!
    if hasSolution && this.foundSolution.setSolved() then
        println("Satisfiable!")
        if this.cdcl.checkCorrectness() then
          println("Solution is correct, and was found by solver number {}:", this.solverId)
          this.cdcl.variableAndValueSelectionPrintout()
        else
          println("Solution is incorrect.")
        end

        val conflicts = this.cdcl.getAllConflicts()
        val assignments = this.cdcl.getAssignments()
        return (Just(true), Just((conflicts.0, conflicts.1, assignments)))
    else if (not hasSolution) then
      println("Problem found unsatisfiable by solver {}", this.solverId)
      return (Just(false), Nothing : Maybe[(int, int, FinalAssignment)])
    else
      return (Just(true), Nothing)
    end
  end

  --
  -- notify
  --
  -- add clauses to my knowledge base. used in combination to the observer pattern
  --
  def notify(clause : Clause): unit
    this.addConflictClause(clause)
  end

  def start(var solveable : Maybe[bool] = Nothing, var solved : bool = false) : (Maybe[bool], Maybe[(int, int, FinalAssignment)])
    WAMP("Starting Loop.")
    repeat i <- this.iterations do
      WAMP("Iterating")
      solved = this.foundSolution.getIsSolved()

      if isNothing(solveable) && not solved then
        val res = this.cdcl.solve()
        solveable = maybe(res.0, solved)
        this.handleConflict(res.1)
      end

      -- if I found the solution before any other solver
      if not isNothing(solveable) && not solved then
        return this.writeSolution(solveable)
      else if solved then
        return (Just(true), Nothing)
      end
    end

    return (solveable, Nothing)
  where
    fun maybe(solveable: Maybe[bool], default : bool) : Maybe[bool]
      if default then
        return Just(true)
      else
        match solveable with
          case Just(x) => return Just(x || default)
          case Nothing => return Nothing
        end
      end
    end

    fun isNothing(solveable: Maybe[bool]): bool
      match solveable with
        case Nothing   => true
        case otherwise => false
      end
    end
  end

  def private handleConflict(conflict: bool): unit
    if conflict then -- conflict
      if this.ccNum == -1 || this.ccSent < this.ccNum then
        val conflictClause = this.cdcl.getLatestConflictClause()
        if this.ccLength == -1 || conflictClause.size() <= this.ccLength then
          this.ccCounter += 1
          if this.ccCounter % this.ccM == 0 then
            this.observable ! notifyAll((this.solverId, this), conflictClause)
            this.ccSent += 1
          end
        end
      end

      -- Considers restarting the process. this is done to start all over
      -- from 0 but keeping the accumulated knowledge from the learnt clauses.
      this.restartCounter += 1
      if this.shouldRestart() then
        this.applyRestart()
      end
    end
  end

  def private shouldRestart(): bool
    this.restartCounter == this.restartCounterMax
  end

  def private applyRestart(): unit
    this.restartCounter = 0
    this.cdcl.restart()
  end

  def addConflictClause(conflictClause : Clause) : unit
    this.cdcl.addConflictClause(conflictClause)
  end
end
